# assignment2
Призначення оригінального запиту:

Вибірка відгуків від застосунків з більш ніж 10 загальними відгуками
Фільтрація позитивних відгуків (оцінка ≥ 3) за останні 2 роки
Включення застосунків з мінімум 5 позитивними відгуками
Виявлення потенційних патернів відгуків (схожі відгуки, різна довжина тексту, розподіл оцінок по місяцях)

Підсумок кроків оптимізації та їх ефекти
Крок 1: Рефакторинг з CTE
Зміна: Перетворення вкладених підзапитів у Common Table Expressions (CTE)
Ефект:

Покращена читабельність та підтримуваність запиту
Краща оптимізація плану виконання базою даних
Усунення дублюючих обчислень підзапитів

Крок 2: Стратегічне індексування
Зміна: Створення цільових індексів для часто запитуваних стовпців
Додані індекси:

idx_main: Композитний індекс на (review_score, helpful_count, review_date, app_id)
idx_positive_reviews: Індекс на (app_id, review_score)
idx_similar_reviews: Індекс на (review_score, helpful_count, app_id)
idx_varied_text: Індекс на (app_id, review_text(100))

Ефект: Значне зменшення операцій сканування таблиць та покращення продуктивності JOIN
Крок 3: Спрощення запиту
Зміна: Видалення невикористовуваних LEFT JOIN та спрощення фінальної структури запиту
Ефект:

Усунення непотрібної складності
Фокус на основних бізнес-вимогах
Зменшення часу виконання через видалення невикористовуваної логіки виявлення патернів

Вплив на продуктивність
Процес оптимізації перетворив складний запит з множинними вкладеними підзапитами в ефективний, індексований запит, який зберігає ту ж бізнес-логіку, але забезпечує кращу продуктивність та підтримуваність.
Структура файлів
├── README.md
├── query_versions/
│   ├── original_query.sql
│   ├── step1_refactor.sql
│   ├── step2_indexing.sql
│   └── optimized_query.sql
├── execution_plans/
│   └── execution_analysis.md
└── explanations/
    └── optimization_guide.md
